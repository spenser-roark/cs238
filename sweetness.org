#+TITLE: Sweetness
#+AUTHOR: Rick Neff
#+EMAIL:  NeffR@byui.edu
#+LANGUAGE:  en
#+OPTIONS:   H:4 num:nil toc:nil \n:nil @:t ::t |:t ^:t *:t TeX:t LaTeX:t

* EN4

  You are invited to explore some of the ramifications of polynomial
  prime generation as it touches probability theory. This invitation to
  exploration is codenamed /Sweetness/.

** Requirements

   Euler's polynomial, \(x^2 + x + 41\), has the /sweet/ feature that
   it computes a prime number for every integer \(x\) in the range \(-40 \le
   x \le 39\), which is 80 primes total. So, in probability terms, the
   chances that you will generate a prime by plugging in a random integer
   in that range are 100%. So no chance about it, it's certain!

   Other polynomials of the form \(f(x) = x^2 + x + C\), where \(C\) is some
   integer constant, can also generate primes, though maybe not as
   reliably as Euler's (which is the special case where \(C=41\)).
   Obviously, different ranges and constants will vary in the number of
   primes generated.

   Suppose the /sweetness/ of a given range+constant pair is a
   quantity with the following properties: The more integers in the range
   that generate primes through this constant plugged into the polynomial
   (and taking the absolute value, \(\left| f(x) \right|\)), the higher the
   sweetness. But the less /uniform/ the distribution of primes
   generated in that range with that constant, the lower the
   sweetness. So the first example, with range+constant \(-40 \le x \le
   39, C=41\), is pretty sweet --- it's completely uniform (i.e., there
   are zero gaps). But widening the range would potentially lower the
   sweetness, because it might less reliably generate primes (i.e., there
   are some gaps).

   How would you define sweetness to quantify these properties? That is
   the first challenge of this exploration. Then there is a trade-off
   analysis task --- to find a range and a constant that have a sweetness
   value as high as possible (up to the arbitrary computational limit of
   what intermediate as well as final \(x\) values fit in the elisp integer
   type). To fix one degree of freedom, which will save some time, use a
   constant size of ten thousand for the range.

   Write code that conducts the sweetness search as systematically as
   possible. You must also create a straightforward Sieve of
   Eratosthenes implementation to test primality, rather than using a
   *probabilistic algorithm*. Why? Because an *isProbablyPrime*
   function would be overkill --- too sour --- you want sweet
   certainty!

** Expectations

   In addition to writing elisp code, you are expected to write a
   report having a good introduction (stating the goal of this
   activity) and conclusion (summarizing your results), and using
   correct grammar and spelling throughout.

   You are also expected to use *org mode* to write your report.

** What Is True?

  The following code block is a self-assesssment tool that allows you to
  use "fuzzy logic" (truth values from 0 to 100):

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun what-is-true-about-my-engagement-with-sweetness ()
    "If need be, replace a 100 with a smaller number to reflect how much you feel you deserve."
    (vector
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; What is true of my experience in general?                              ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  ["I had fun." 5]
  ["I collaborated with one or more classmates." 100]
  ["I learned something new." 100]
  ["I achieved something meaningful, or something I can build upon at a later time." 100]

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; What is true of my report on what I learned?                            ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  ["I used org mode to write it." 100]
  ["I explain usage of my code with plain instructions on how to run WITH command-line parameters to show what it can do." 100]

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; What is true of the mechanical "infelicities" (misspelled words,        ;;
  ;; grammatical errors, punctuation errors) in my report of what I learned? ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  ["There are fewer than four." 100]
  ["There are fewer than three." 100]
  ["There are fewer than two." 100]
  ["There are none." 100]

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; What is true of how my code is parameterized?                           ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  ["It runs without the need for user input via files, or other non-command-line input." 100]
  ["Thus it uses command-line parameters only." 100]
  ["With command-line parameters it allows the user to choose which tests to run." 100]
  ["With command-line parameters it allows for computing the sweetness value of a specific range/constant pair." 50]

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; What is true of my Sieve of Erathosthenes code?                         ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  ["It avoids the waste of calculating more primes than necessary." 100]
  ["It avoids the waste of calculating and putting primes in a vector (or other collection type) and determining primeness by searching the vector." 100]
  ["It is efficient, filling a bool-vector one time up front, and answering 'Is n prime' by returning the n'th element of this array." 100]
  ["It fills this bool array in under a minute on an unloaded Linux lab node." 100]

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; What is true of how my code does calculations, in general?              ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  ["It respects the limit of what intermediate results (like x * x) fit in an elisp fixnum." 100]
  ["It respects the limit of what will fit in an elisp fixnum overall." 100]
  ["It accounts for the fundamental feature of the distribution of primes that smaller numbers are more likely to be prime than larger ones." 100]
  ["It calculates unique primes for the best range/constant pairs --- NO duplicates." 100]

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; What is true of how my code calculates sweetness, in particular?        ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  ["It uses a measure of plenitude probabilistically, meaning 0 <= p <= 1." 100]
  ["It uses a measure of distribution sparingly --- in other words, conditionally." 100]
  ["It uses judicious conditions for applying this measure." 100]
  ["It uses this measure accurately." 100]
  ))

#+END_SRC
   
